Чтобы создать новый протокол, надо реализовать его уровни как наследников класса NetModule - модулей.

Каждый NetObject собирается из таких модулей, которые пересылают друг другу объекты класса IPacket.

Для этого у каждого модуля есть методы интерфейса IModule, такие, как:

- IGate declareGate(String name)
- IGate getGate(String name)

Они позволяют задать "порты", через которые пресылаются сообщения. Параметр name - уникальное в рамках модуля имя порта. Чтобы обозначить связь, пару таких портов нужно соединить между собой либо односторонне, либо дуплексно, например, так:

	// IGate gate <-> IGate dest
	gate.setTo(dest);
	dest.setFrom(gate);
	gate.setFrom(dest);
	dest.setTo(gate);

Очевидно, одностороннее соединение выглядит так:

	// IGate gate -> IGate dest
	gate.setTo(dest);
	dest.setFrom(gate);

Чтобы обрабатывать пакет, необходимо перегрузить метод recieveMessage модуля:
- boolean recieveMessage(IPacket m);
Внутри этого метода можно обращаться к полю модуля "String arrivedOn", чтобы определить, на какой из портов пришло сообщение (IPacket), это поле содержит имя соответствующего порта.

Теперь необходимо заняться созданием элемента сети (ЭС - NetObject или Mot), который содержит этот протокол.

Для обмена сообщениями с другими элементами сети служит метод sendMessage(IMessage m) диспетчера. Соответственно, получают сообщения от диспетчера эС тоже в виде IMessage: recieveMessage(IMessage m). Они содержат наследников IPacket в качестве данных. Соответственно, чтобы определить, какому из модулей пересылать пришедшее сообщение, ЭС содержит по порту на каждый класс, методы:

- IGate declareInputGate(Class<? extends IPacket> msgClass);
- IGate getInputGate(Class<? extends IPacket> msgClass);
- boolean hasInputGate(Class<? extends IPacket> msgClass);

И именно с ними необходимо соединить модуль, который получит исходное сообщение.

