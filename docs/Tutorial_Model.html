<html>
<title>JWSN - Создание новой модели</title>
<head></head>
<h2>Краткое описание:</h2>
<p>
JWSN - инструмент разработчика протоколов. Ориентирован на работу в беспроводной сети, однако может быть расширен разработчиком для моделирования, к примеру, проводных и любых других сетей, в которых осуществляется обмен сообщениями.
</p>
<p>
Разработчику предоставляется механизм создания многоуровневой структуры поведения элементов сети и их взаимодействия, графический интерфейс визуализатора, подробный логгер событий системы. Реализована возможность запускать симулятор без графического интерфейса для моделирования крупных систем, анализа логов.
</p>
<h2>Чтобы создать новую модель, необходимо выполнить следующую последовательность действий:</h2>
<body>
<p>
1. Объявить необходимое количество мотов или любых других объектов с суперклассом NetObject.
</p>
<pre>
   Mot m1 = new Mot(100, 100, power, threshold);
   Mot m2 = new Mot(300, 100, power, threshold);
   Mot m3 = new Mot(200, 100, 100 * power, threshold);

   m1.addModule("mac", new CommonMac(m1));
   m1.addModule("net", new Net(m1));
   m1.addModule("app", new SenderApp(m1));

   m2.addModule...
   m3.addModule...
</pre>
<p>
2. При линейной топологии модулей внутри мота можно напрямую её задать, первые 3 уровня зарезервированы под mac, net и app. Иначе либо соединять вручную (как показано в Tutorial_Protocol), либо перегружать createTopology.
</p>
<pre>
   m1.createTopology();
   m2.createTopology();
   m3.createTopology();
</pre>
<p>
3. Возможно считать описания из файла.
</p>
<pre>
  List<Mot> mots = new LinkedList<Mot>();
  mots.add(m1); mots.add(m2); mots.add(m3);
  try {
  	FieldParser.ReadStyles(new FileInputStream("Descriptions.xml"), mots);
  } catch (FileNotFoundException nf) { ... }
</pre>
<p>
4. Задать топологию сети для hard-coded протоколов.
</p>
<pre>
  IDispatcher disp = Dispatcher.getInstance();
  IGraph<Integer> g = new Graph<Integer>();

  for (int i = 0; i < 3; i++) {
  	g.newVertex(new Integer(i));
  }
		
  g.addNeighbour(0, 1);
  ...		
  g.solvePaths(2);
  disp.setTopology(g);
</pre>
<p>
5. Создать UI.
</p>
<pre>
  BasicUI.createUI();
</pre>
<p>
6. Добавить слушателей, чтобы их отобразил визуализатор.
</p>
<pre>
  disp.addActiveObjectListener(m1);
  disp.addActiveObjectListener(m2);
  disp.addActiveObjectListener(m3);
</pre>
<h2>Чтобы создать новый протокол, необходимо выполнить следующую последовательность действий:</h2>
<body>
<p>
Каждый NetObject собирается из таких модулей, которые пересылают друг другу объекты класса IPacket.

Для этого у каждого модуля есть методы интерфейса IModule, такие, как:
</p>
<pre>
- IGate declareGate(String name)
- IGate getGate(String name)
</pre>
<p>
Они позволяют задать "порты", через которые пресылаются сообщения. Параметр name - уникальное в рамках модуля имя порта. Чтобы обозначить связь, пару таких портов нужно соединить между собой либо односторонне, либо дуплексно, например, так:
</p>
<pre>
   // IGate gate <-> IGate dest
   gate.setTo(dest);
   dest.setFrom(gate);
   gate.setFrom(dest);
   dest.setTo(gate);
</pre>
<p>
Очевидно, одностороннее соединение выглядит так:
</p>
<pre>
   // IGate gate -> IGate dest
   gate.setTo(dest);
   dest.setFrom(gate);
</pre>
<p>
Чтобы обрабатывать пакет, необходимо перегрузить метод recieveMessage модуля:
- boolean recieveMessage(IPacket m);
Внутри этого метода можно обращаться к полю модуля "String arrivedOn", чтобы определить, на какой из портов пришло сообщение (IPacket), это поле содержит имя соответствующего порта.

Теперь необходимо заняться созданием элемента сети (ЭС - NetObject или Mot), который содержит этот протокол.

Для обмена сообщениями с другими элементами сети служит метод sendMessage(IMessage m) диспетчера. Соответственно, получают сообщения от диспетчера эС тоже в виде IMessage: recieveMessage(IMessage m). Они содержат наследников IPacket в качестве данных. Соответственно, чтобы определить, какому из модулей пересылать пришедшее сообщение, ЭС содержит по порту на каждый класс, методы:
</p>
<pre>
- IGate declareInputGate(Class<? extends IPacket> msgClass);
- IGate getInputGate(Class<? extends IPacket> msgClass);
- boolean hasInputGate(Class<? extends IPacket> msgClass);
</pre>
<p>
И именно с ними необходимо соединить модуль, который получит исходное сообщение.
</p>
</html>